//+------------------------------------------------------------------+
//|                                                libOrdersFunc.mq4 |
//|                      Copyright © 2011, Morochin <artamir> Artiom |
//|               http://forexmd.ucoz.org  e-mail: artamir@yandex.ru |
//+------------------------------------------------------------------+
#property copyright "Copyright © 2011, Morochin <artamir> Artiom"
#property link      "http://forexmd.ucoz.org  e-mail: artamir@yandex.ru"
#property library

#include <libHelpFunc.mqh>
#include <libINIFileFunc.mqh>
/*///===================================================================
   Версия: 2011.03.24
   ---------------------
   Описание:
      инициализация констант
   ---------------------
   Доп. функции:
      нет
   ---------------------
   Константы:
       OP_SLTP = применяется как флаг операций вычисления сл и тп для ордеров         
       OP_SORD = применяется как флаг операций открытия позиции
/*///-------------------------------------------------------------------
#define  libNAME "libOrdersFunc"

#define  OP_SLTP   200
#define  OP_SORD   100

#define  CHK_SMBMN    500
#define  CHK_SMB      700
#define  CHK_MN       600
#define  CHK_TYMORE   400
#define  CHK_TYLESS   300
#define  CHK_TYEQ     200

string   EXP_NAME =   "";
//======================================================================
string   file_ord =  "";

void libOrders_setFile_ord(string str){
   file_ord = str;
}

/*///==================================================================
// Версия: 2011.03.24
//---------------------
// Описание:
// Возвращает версию библиотеки помощи :)
//---------------------
// Переменные:
//    нет
/*///-------------------------------------------------------------------
string libOrders_Ver(){
   return("v1.0");
}
//======================================================================

/*///===================================================================
   Версия: 2011.03.24
   ---------------------
   Описание:
      проверяет, является ли ордер родительским
   ---------------------
   Доп. функции:
      нет
   ---------------------
   Переменные:
      ticket       = тикет проверяемого ордера
      magic        = магик советника
/*///-------------------------------------------------------------------
bool  isParentOrder(int ticket, int magic){
   //================
      if(!checkOrderByTicket(ticket, CHK_TYLESS, "", magic, 1)) return(false); // проверим, чтоб ордер был рыночным
      //----
      if(!OrderSelect(ticket, SELECT_BY_TICKET)) return(false); //на всякий случай
   //================
   // Попытаемся проверить ини файл родительских ордеров
   int isParent = StrToInteger(ReadIniString(file_ord, ticket, "isParent", "-1"));
   //----
   if(isParent == -1){
      if(OrderComment() == "" || StrToInteger(returnComment(OrderComment(),"@i")) > -1)
         return(true);
      else
         return(false);   
   }
}
//======================================================================

/*///===================================================================
	Версия: 2011.03.31
	---------------------
	Описание:
		проверяем, является ли родительский ордер живым
	---------------------
	Доп. функции:
		нет
	---------------------
	Переменные:
		нет
/*///-------------------------------------------------------------------
bool isParentLive(int ticket){
	bool res = false;
		//{==========
			if(!OrderSelect(ticket, SELECT_BY_TICKET)) return(false);
			//---
		//}
		
		string comm = OrderComment();
		
		int parent_ticket = StrToInteger(returnComment(comm, "@p"));
		if(!OrderSelect(parent_ticket, SELECT_BY_TICKET)){
			parent_ticket = StrToInteger(ReadIniString(file_ord, ticket, "parent", "-1"));
			if(!OrderSelect(parent_ticket,SELECT_BY_TICKET)){
				return(false);
			}else{
				if(OrderCloseTime() != 0){
					return(false);
				}else{
					return(true);
				}
			}
		}else{
			if(OrderCloseTime() == 0) 
				return(true);
			else
				return(false);
		}
	return(res);
}
//======================================================================

/*///===================================================================
	Версия: 2011.03.31
	---------------------
	Описание:
		Возвращает родителя из истории
	---------------------
	Доп. функции:
		нет
	---------------------
	Переменные:
		нет
/*///-------------------------------------------------------------------
int getParentInHistory(int ticket){
	int res = -1;
		//{==========
			if(!OrderSelect(ticket, SELECT_BY_TICKET)) return(-1);
			//---
		//}
		
		string comm = OrderComment();
		
		int parent_ticket = StrToInteger(returnComment(comm, "@p"));
		if(!OrderSelect(parent_ticket, SELECT_BY_TICKET)){
			parent_ticket = StrToInteger(ReadIniString(file_ord, ticket, "parent", "-1"));
			if(!OrderSelect(parent_ticket,SELECT_BY_TICKET)){
				return(-1);
			}else{
				return(parent_ticket);
			}
		}else{
			return(parent_ticket);
		}
	return(res);
}
//======================================================================

/*///===================================================================
   Версия: 2011.03.24
   ---------------------
   Описание:
      проверяет ордер по заданным параметрам
   ---------------------
   Доп. функции:
      нет
   ---------------------
   Переменные:
      ticket       = тикет ордера
      ORD_CHK      = режим проверки
      sy           = валютная пара(опционально)
      MN           = магик номер
      ty           = тип ордера
/*///-------------------------------------------------------------------
bool checkOrderByTicket(int ticket, int ORD_CHK, string sy="", int MN=0, int ty = -1){
   bool res = false;
   //==================
		if(!OrderSelect(ticket,SELECT_BY_TICKET)) return(false);
		//-----
		if(ORD_CHK <= CHK_SMB){
			if(OrderSymbol() != Symbol())          return(false);
			//-----
			if(ORD_CHK <= CHK_MN){
				if(OrderMagicNumber() != MN)        return(false);
				//----
				if(ORD_CHK == CHK_TYMORE){
					if(OrderType() < ty)             return(false);
				}//if(ORD_CHK <= CHK_TYMORE){
				//----
				if(ORD_CHK == CHK_TYLESS){
					if(OrderType() > ty)             return(false);
				}//if(ORD_CHK <= CHK_TYLESS){
				//----
				if(ORD_CHK == CHK_TYEQ){
					if(OrderType() != ty)            return(false);
				}//if(ORD_CHK <= CHK_TYEQ){
				//----
			}//if(ORD_CHK <= CHK_MN){   
			//-----
		}//}} if(ORD_CHK <= CHK_SMB){   
   //==================
   return(true);  // прошли проверку, вернем ТРУ
}
//======================================================================

/*///===================================================================
   Версия: 2011.03.24
   ---------------------
   Описание:
      Запрос на открытие рыночного ордера с выставлением тп и сл в пунктах 
   ---------------------
   Доп. функции:
      ._OrderSend()-открываем ордер без тп и сл
      ._OrderModify() - устанавливаем тп и сл относительно открытого ордера
   ---------------------
   Переменные:
      

/*///-------------------------------------------------------------------
int OpenMarketSLTP_pip(	string		sy		=	""		,
						int			cmd		=	-1		,
						double		lot		=	0		,
						double		pr		=	0		,
						int			sl_pip	=	0		,
						int			tp_pip	=	0		,
						string		comm	=	""		,
						int			MN		=	0		,
						datetime	exp		=	0		,
						color		cl		=	CLR_NONE){
   int res = _OrderSend(sy, cmd, lot, pr, 0, 0, 0, comm, MN, exp, cl);
   //============
   if(res > -1){
      OrderSelect(res, SELECT_BY_TICKET);
             pr = OrderOpenPrice();
      double sl = pr + iif(cmd == OP_BUY,-1,1) * sl_pip*Point;
      double tp = pr + iif(cmd == OP_BUY,1,-1) * tp_pip*Point;
      
      if( _OrderModify( res, -1, sl, tp, MN, -1, CLR_NONE))
         return(res);   
      else              // заглушка на случай неудачной модификации ордера
         return(res);         
   }else{
      return(-1);     
   }//}}if(res > -1){   
} 
//======================================================================

/*///===================================================================
   Версия: 2011.03.24
   ---------------------
   Описание:
      Запрос на открытие отложенного ордера с отступом х пип от тек. цены 
      с выставлением тп и сл в пунктах 
   ---------------------
   Доп. функции:
      ._OrderSend()-открываем ордер без тп и сл
      ._OrderModify() - устанавливаем тп и сл относительно открытого ордера
   ---------------------
   Переменные:
      

/*///-------------------------------------------------------------------
int OpenPendingPRSLTP_pip(	string		sy		=	""			, 
							int			cmd		=	-1			, 
							double		lot		=	0			, 
							int			pr		=	0			, 
							int			sl_pip	=	0			, 
							int			tp_pip	=	0			, 
							string		comm	=	""			, 
							int			MN		=	0			, 
							datetime	exp		=	0			, 
							color		cl		=	CLR_NONE	){
   
   if(sy == ""){
      sy = Symbol();
   }
   //----
   double pending_pr = MarketInfo(sy, MODE_BID) + orderDirection(cmd,OP_SORD)*pr*Point;
   
   int res = _OrderSend(sy, cmd, lot, pending_pr, 0, 0, 0, comm, MN, exp, cl);
   //============
   if(res > -1){
      OrderSelect(res, SELECT_BY_TICKET);
             pending_pr = OrderOpenPrice();
              double sl = pending_pr - orderDirection(cmd,OP_SLTP) * sl_pip*Point;
              double tp = pending_pr + orderDirection(cmd,OP_SLTP) * tp_pip*Point;
      
      if( _OrderModify( res, -1, sl, tp, MN, -1, CLR_NONE))
         return(res);   
      else              // заглушка на случай неудачной модификации ордера
         return(res);         
   }else{
      return(-1);     
   }//}}if(res > -1){   
} 
//======================================================================

/*///===================================================================
	Версия: 2011.04.02
	---------------------
	Описание:
		Модифицирует тп и сл (опционально) ордера
	---------------------
	Доп. функции:
		._OrderModify()
	---------------------
	Переменные:
		ticket
		tp_pip
		sl_pip
		magic
/*///-------------------------------------------------------------------
bool ModifyOrder_TPSL_pip(int ticket, int tp_pip, int sl_pip, int magic){
	
	bool res = false;

	if(!OrderSelect(ticket, SELECT_BY_TICKET)) return(false);
	//======
	if(OrderCloseTime() > 0){
		addInfo("Order: "+ticket+" is CLOSED!!!!");
		return(false);
	}
	//----
		double oop = NormalizeDouble(OrderOpenPrice(), 	Digits);
		double otp = NormalizeDouble(OrderTakeProfit(), Digits);
		double osl = NormalizeDouble(OrderStopLoss(),	Digits);
		//---
		double calc_tp = 0;
		double calc_sl = 0;
		//---
		if(OrderType() == OP_BUY || OrderType() == OP_BUYSTOP || OrderType() == OP_BUYLIMIT){
			calc_tp = (oop + tp_pip*Point);
			calc_sl = (oop - sl_pip*Point);
		}
		//---
		if(OrderType() == OP_SELL || OrderType() == OP_SELLSTOP || OrderType() == OP_SELLLIMIT){
			calc_tp = (oop - tp_pip*Point);
			calc_sl = (oop + sl_pip*Point);
		}
		//---
		calc_tp = NormalizeDouble(calc_tp, Digits);
		calc_sl = NormalizeDouble(calc_sl, Digits);
		//---
		if(calc_tp == otp && calc_sl == osl){
			return(true);
		}else{
			res = _OrderModify(ticket, -1, calc_sl, calc_tp, magic, -1, CLR_NONE);
			return(res);
		}
		
}
//======================================================================

/*///===================================================================
         ЗАКРЫТЫЕ ФУНКЦИИ БИБЛИОТЕКИ		 
/*///===================================================================   
//{
      
/*///===================================================================
   Версия: 2011.03.24
   ---------------------
   Описание:
      Запрос на открытие позиции
   ---------------------
   Доп. функции:
      ._OrderModify()
               .checkOrderByTicket(int ticket, int CHK_OPTION)
   ---------------------
   Переменные:
      см. в теле процедуры

/*///-------------------------------------------------------------------
int _OrderSend(string    _symbol,
                  int    _cmd, 
                  double _volume, 
                  double _price, 
                  int    _sleepage, 
                  double _stoploss, 
                  double _takeprofit, 
                  string _comment, 
                  int    _magic, 
                  int    _exp, string fn = ""){
   /*
   symbol   -   Наименование финансового инструмента, с которым проводится торговая операция. 
   cmd   -   Торговая операция. Может быть любым из значений торговых операций.  
   volume   -   Количество лотов. 
   price   -   Цена открытия. 
   slippage   -   Максимально допустимое отклонение цены для рыночных ордеров (ордеров на покупку или продажу). 
   stoploss   -   Цена закрытия позиции при достижении уровня убыточности (0 в случае отсутствия уровня убыточности). 
   takeprofit   -   Цена закрытия позиции при достижении уровня прибыльности (0 в случае отсутствия уровня прибыльности). 
   comment   -   Текст комментария ордера. Последняя часть комментария может быть изменена торговым сервером.  
   magic   -   Магическое число ордера. Может использоваться как определяемый пользователем идентификатор. 
   expiration   -   Срок истечения отложенного ордера. 
   arrow_color   -   Цвет открывающей стрелки на графике. Если параметр отсутствует или его значение равно CLR_NONE, то открывающая стрелка не отображается на графике. 
   
   если price == 0 тогда открываем по текущей цене
   */
   int res        = -1;
   int countOfTry = 5;
   int nTry       = 0;
   
   int sltpLevel = MarketInfo(Symbol(),MODE_STOPLEVEL);
 
   
   
   while(      res   <   0                && nTry  <=  countOfTry 
                     &&  !IsStopped()     &&           IsTradeAllowed()){
      
      //---            
      if(!IsExpertEnabled()) break;
      //---
      
      if(_cmd <= 1 && _price <= 0){
         _price = iif(_cmd == OP_BUY, MarketInfo(Symbol(), MODE_ASK), MarketInfo(Symbol(), MODE_BID));
      }
      //---
      if(_price > 0 ){
         if(_cmd == OP_BUYSTOP || _cmd == OP_SELLLIMIT){
            if(_price < (MarketInfo(Symbol(),MODE_ASK) + sltpLevel  *  Point)){
               logInfo(StringConcatenate("cant open ", "ot = ",_cmd, " op = ",_price," fn = OpenOrder"),libNAME+" : _OrderSend");
               return(-1);
            }
         }
         //***
         if(_cmd == OP_SELLSTOP || _cmd == OP_BUYLIMIT){
            if(_price > (MarketInfo(Symbol(),MODE_BID) - sltpLevel  *  Point)){
              logInfo(StringConcatenate("cant open ", "ot = ",_cmd, " op = ",_price," fn = OpenOrder"),libNAME+" : _OrderSend");
               return(-1);
            }
         }
      }
      
      //нормализуем все переменные зависящие от цены
      _price      = NormalizeDouble(_price,      Digits);  
      _stoploss   = NormalizeDouble(_stoploss,   Digits);
      _takeprofit = NormalizeDouble(_takeprofit, Digits);
              
      res = OrderSend(_symbol, _cmd, _volume, _price, _sleepage, 0, 0, _comment, _magic, _exp, CLR_NONE);
      
      logInfo(StringConcatenate("OpenOrder = ",res), "");
      
      if(res > -1 && (_stoploss > 0 || _takeprofit > 0)){
         if(_OrderModify(res,-1,_stoploss,_takeprofit,_magic,_exp,CLR_NONE))
            return(res);   
      }   
      //---
      int err = GetLastError();
      if(err > 0)
      {
         if(err == 4109){
            logInfo("TRADE IS DISABLED!!!!", "");
            addInfo("TRADE IS DISABLED!!!!");
            return(-1);
         }   
            
         if(err == 4051)
            break;   
         //logInfo(_price);
         if(err == 148){
            logInfo("BROCKER MAX ORDERS!!!!!", "");
            addInfo("BROCKER MAX ORDERS!!!!!");
            return(-1);
         }
         
         if(err == 130){
            logInfo(StringConcatenate("sl = ",_stoploss," tp = ",_takeprofit), "");
            return(-1);
         }
         logError("OpenOrder",StringConcatenate("OrderSendError, fn = ",fn),err);
         logInfo(StringConcatenate("Price = ",_price," cmd = ",_cmd, " bid = ", Bid, " ask = ", Ask), "");
      }
      
      nTry++;
   }
   
return(res);   
}
//======================================================================

/*///===================================================================
   Версия: 2011.03.24
   ---------------------
   Описание:
      Производит модификацию ценовых значений ордера
   ---------------------
   Доп. функции:
      .checkOrderByTicket(int ticket, int CHK_OPTION)
   ---------------------
   Переменные:
      condition    = логическое сравнение
      ifTrue       = значение в случае condition = ИСТИНА
      ifFalse      = значение в случае condition = ЛОЖЬ

/*///-------------------------------------------------------------------
bool _OrderModify( 	int 		ticket					, 
					double 		price					, 
					double 		stoploss				, 
					double 		takeprofit				, 
					int 		MN 			= 	0		, 
					datetime 	expiration	=	-1		, 
					color 		clr			=	CLR_NONE){
   bool res = false;   
   //===================
      if(!checkOrderByTicket(ticket, CHK_SMBMN, "", MN, -1)) return(false);
   //===================   
   // Проверка на возможность работы советника
   
   OrderSelect(ticket,SELECT_BY_TICKET);
   
   if(price       < 0) price       = OrderOpenPrice();
   //-----
   if(stoploss    < 0) stoploss    = OrderStopLoss();
   //-----
   if(takeprofit  < 0) takeprofit  = OrderTakeProfit();
   //-----
   if(expiration  < 0) expiration  = OrderExpiration();
   //-----
   // Нормализуем все переменные
      price       = NormalizeDouble(price,      Digits);
      stoploss    = NormalizeDouble(stoploss,   Digits);
      takeprofit  = NormalizeDouble(takeprofit, Digits);      
   //-----
   int nTry = 5;
   int i    = 1;
   
   while(!res && i <= nTry && (IsExpertEnabled() || IsTesting()) && !IsStopped()){
      //---
      while(IsTradeContextBusy()) Sleep(1000*5);
      //---
      res = OrderModify(ticket, price, stoploss, takeprofit, expiration, clr);   
      //==========================   
      i++;
   }
   //==========
   // Разбираемся с результатом:
   if(res)
      return(true);
   else{
      logError("libOrdersFunc : _OrderModify()","",GetLastError());   
      return(res);
   }   
} 

//}======================================================================